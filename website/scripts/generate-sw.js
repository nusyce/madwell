import dotenv from 'dotenv';
import { writeFileSync, existsSync } from 'fs';
import { fileURLToPath } from 'url';
import { dirname, join } from 'path';

// Get the current directory in ES modules
const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

// Load environment variables from multiple files (Next.js convention)
// Priority: .env.local > .env (later loads override earlier)
const envFiles = [
  join(__dirname, '..', '.env'),
  join(__dirname, '..', '.env.local'),
];

envFiles.forEach(file => {
  if (existsSync(file)) {
    dotenv.config({ path: file });
  }
});

// Read Firebase config token for API authentication
// This token is used to secure the /api/sw-init endpoint
const firebaseConfigToken = process.env.NEXT_PUBLIC_FIREBASE_CONFIG_TOKEN;

if (!firebaseConfigToken) {
  console.error('âŒ Error: FIREBASE_CONFIG_TOKEN environment variable is missing');
  console.error('   This token is required to secure the Firebase config API endpoint.');
  console.error('   Generate a random token and add it to your .env file:');
  console.error('   FIREBASE_CONFIG_TOKEN=your-random-token-here');
  console.error('\n   You can generate a token using:');
  console.error('   node -e "console.log(require(\'crypto\').randomBytes(32).toString(\'hex\'))"');
  process.exit(1);
}

// Read required Firebase environment variables (for validation only)
const firebaseConfig = {
  apiKey: process.env.NEXT_PUBLIC_FIREBASE_API_KEY,
  authDomain: process.env.NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN,
  projectId: process.env.NEXT_PUBLIC_FIREBASE_PROJECT_ID,
  storageBucket: process.env.NEXT_PUBLIC_FIREBASE_STORAGE_BUCKET,
  messagingSenderId: process.env.NEXT_PUBLIC_FIREBASE_MESSAGEING_SENDER_ID,
  appId: process.env.NEXT_PUBLIC_FIREBASE_APP_ID,
  measurementId: process.env.NEXT_PUBLIC_FIREBASE_MESUMENT_ID,
};

// Validate that all required environment variables are present
const missingVars = Object.entries(firebaseConfig)
  .filter(([key, value]) => !value)
  .map(([key]) => key);

if (missingVars.length > 0) {
  console.error('âŒ Error: Missing required environment variables:');
  missingVars.forEach((key) => {
    console.error(`   - ${key}`);
  });
  console.error('\nPlease ensure all Firebase config variables are set in .env');
  process.exit(1);
}

// Generate the service worker file content
// This version fetches config dynamically from API endpoint instead of hardcoding
// Includes complete notification handling with redirect logic
const swContent = `/* -----------------------------------------------------
   Firebase Messaging Service Worker (Production Ready)
   Generated by scripts/generate-sw.js
   Credentials are fetched securely from API endpoint
------------------------------------------------------ */

importScripts("https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js");
importScripts("https://www.gstatic.com/firebasejs/8.10.1/firebase-messaging.js");

// Firebase instance - initialized dynamically
let messaging = null;
let isInitialized = false;

/* -----------------------------------------------------
   Service Worker Lifecycle Events
   CRITICAL: These ensure immediate activation in production
------------------------------------------------------ */
// Force service worker to activate immediately (skip waiting)
self.addEventListener("install", function (event) {
  self.skipWaiting();
});

// Claim all clients immediately when service worker activates
self.addEventListener("activate", function (event) {
  event.waitUntil(self.clients.claim());
});

/* -----------------------------------------------------
   Helper: Build redirect URL based on notification type
   Handles all backend notification types
------------------------------------------------------ */
function getRedirectUrl(data) {
  if (!data) {
    return "/";
  }

  // Get type from backend - only 'type' field is supported now
  const type = (data.type || "").trim().toLowerCase();

  // If no type specified, return home
  if (!type) {
    return "/";
  }

  // PROVIDER redirects â†’ /provider-details/{slug}
  if (type === "provider" || type === "provider_details") {
    const slug =
      data.provider_slug ||
      data.providerSlug ||
      data.slug ||
      data.provider_id ||
      data.providerId ||
      data.id;

    if (slug) {
      return \`/provider-details/\${slug}\`;
    }
    return "/";
  }

  // SERVICE redirects â†’ /provider-details/{provider}/{service}
  if (type === "service" || type === "service_details") {
    const p = data.provider_slug || data.providerSlug || data.provider_id || data.providerId;
    const s = data.service_slug || data.serviceSlug || data.slug || data.service_id || data.serviceId;
    if (p && s) {
      return \`/provider-details/\${p}/\${s}\`;
    }
    return "/";
  }

  // CATEGORY redirects â†’ /service/{parent1}/{parent2}/.../{slug}
  if (type === "category") {
    let base = "/service";
    
    // Get parent slugs - handle both array and string formats
    let parents = data.parent_category_slugs || 
                  data.parentCategorySlugs || 
                  data.parent_slugs || 
                  data.parent_categories || 
                  [];
    
    // If parents is a string, try to parse it as JSON array
    if (typeof parents === "string") {
      try {
        parents = JSON.parse(parents);
      } catch (e) {
        parents = parents.split(",").map(p => p.trim()).filter(p => p);
      }
    }
    
    if (!Array.isArray(parents)) {
      parents = [];
    }
    
    const slug = data.category_slug || 
                data.categorySlug || 
                data.slug || 
                data.category_id || 
                data.categoryId;

    if (Array.isArray(parents) && parents.length > 0) {
      const validParents = parents
        .map(p => String(p).trim())
        .filter(p => p && p.length > 0);
      
      if (validParents.length > 0) {
        base += "/" + validParents.join("/");
      }
    }
    
    if (slug) {
      const cleanSlug = String(slug).trim();
      if (cleanSlug) {
        base += "/" + cleanSlug;
      }
    }

    if (base !== "/service") {
      return base;
    }
    
    return "/";
  }

  // BLOG redirects â†’ /blog-details/{slug}
  if (type === "new_blog") {
    const slug = data.blog_slug || 
                data.blogSlug || 
                data.slug || 
                data.blog_id || 
                data.blogId;
    if (slug) {
      return \`/blog-details/\${slug}\`;
    }
    return "/";
  }

  // BOOKING-related notifications â†’ /booking/{id}
  const bookingTypes = [
    "booking_status_updated",
    "booking_confirmed",
    "booking_rescheduled",
    "booking_cancelled",
    "booking_completed",
    "booking_started",
    "booking_ended",
    "added_additional_charges",
    "online_payment_failed",
    "online_payment_success",
    "online_payment_pending",
    "rating_request_to_customer",
    "bid_on_custom_job_request",
    "payment_refund_executed",
    "payment_refund_successful",
    "booking",
    "booking_status",
    "order"
  ];

  if (bookingTypes.includes(type)) {
    const id = data.booking_id || 
              data.bookingId || 
              data.order_id || 
              data.orderId || 
              data.id;
    if (id) {
      return \`/booking/inv-\${id}\`;
    }
    return "/";
  }

  // CHAT/MESSAGE redirects â†’ /chats
  if (type === "chat" || type === "message" || type === "new_message") {
    return "/chats";
  }

  // USER ACCOUNT notifications - no redirect
  if (type === "user_account_active" || type === "user_account_deactive") {
    return "/";
  }

  // USER MODERATION notifications - no redirect
  if (type === "user_reported" || type === "user_blocked") {
    return "/";
  }

  // POLICY/SETTINGS notifications - no redirect
  if (type === "privacy_policy_changed" || type === "terms_and_conditions_changed") {
    return "/";
  }

  // MAINTENANCE MODE - no redirect
  if (type === "maintenance_mode") {
    return "/";
  }

  // Direct custom URL
  if (type === "url" && data.url) {
    return data.url;
  }

  // Unknown type - redirect to home
  return "/";
}

/* -----------------------------------------------------
   Initialize Firebase with config fetched from secure API
   
   SECURITY NOTE: The token below is intentionally embedded at build time.
   Service workers cannot access environment variables at runtime.
   This token only authenticates requests to our own API that returns
   Firebase config (which uses NEXT_PUBLIC_ variables - already public).
   This is NOT a security risk - it's a design limitation of service workers.
------------------------------------------------------ */
async function initializeFirebase() {
  if (isInitialized) return;
  
  try {
    // Token embedded during build time - required for service worker authentication
    // This token protects access to public Firebase config, not sensitive data
    // deepcode ignore HardcodedNonCryptoSecret: Service workers require embedded tokens - this only protects public Firebase config
    const token = "${firebaseConfigToken}";
    const requestTime = Date.now();
    const clientId = btoa(Date.now().toString() + Math.random().toString()).substring(0, 16);
    
    // Fetch config from secure API endpoint
    const response = await fetch('/api/sw-init', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-Auth-Token': token,
        'X-Request-Time': requestTime.toString(),
        'X-Service-Worker': 'true',
        'Accept': 'application/json',
      },
      body: JSON.stringify({
        action: 'init',
        clientId: clientId,
        timestamp: requestTime
      }),
      credentials: 'same-origin'
    });
    
    if (!response.ok) {
      throw new Error(\`Failed to fetch config: \${response.status}\`);
    }
    
    const firebaseConfig = await response.json();
    
    // Initialize Firebase
    firebase.initializeApp(firebaseConfig);
    messaging = firebase.messaging();
    isInitialized = true;
    
    console.log('ðŸ”¥ [SW] Firebase initialized successfully');
  } catch (error) {
    console.error('ðŸ”¥ [SW] Error initializing Firebase:', error);
    // Retry after delay
    setTimeout(initializeFirebase, 5000);
  }
}

// Start initialization
initializeFirebase();

/* -----------------------------------------------------
   FCM Background Notification Handler (Push Event)
------------------------------------------------------ */
self.addEventListener("push", function (event) {
  if (!event.data) {
    return;
  }

  try {
    const payload = event.data.json();
    const data = payload.data || {};

    const title = payload.notification?.title || data.title || "Notification";
    const body = payload.notification?.body || data.body || "";
    const icon = data.icon || data.image || "/favicon.ico";

    // Build redirect URL from notification data
    const redirectUrl = getRedirectUrl(data);
      
    const options = {
      body,
      icon,
      data: { url: redirectUrl, originalData: data },
      requireInteraction: false,
    };

    event.waitUntil(
      self.registration.showNotification(title, options)
    );
  } catch (e) {
    console.error("ðŸ”” [SW] Error processing push notification:", e);
  }
});

/* -----------------------------------------------------
   Notification Click Handler â†’ Focus or open tab
------------------------------------------------------ */
self.addEventListener("notificationclick", function (event) {
  const notificationData = event.notification.data || {};
  let url = notificationData.url || "/";
  const originalData = notificationData.originalData || {};
  
  // Recalculate URL if missing
  if (!url || url === "/" || url === "") {
    if (originalData && Object.keys(originalData).length > 0) {
      url = getRedirectUrl(originalData);
    } else {
      url = "/";
    }
  }
  
  event.notification.close();
  
  // Build full absolute URL
  const origin = self.location.origin;
  let fullUrl = url;
  
  if (!url.startsWith("http://") && !url.startsWith("https://")) {
    const cleanUrl = url.startsWith("/") ? url : "/" + url;
    fullUrl = origin + cleanUrl;
  }

  event.waitUntil(
    clients
      .matchAll({ 
        type: "window", 
        includeUncontrolled: true 
      })
      .then((windowClients) => {
        // Look for existing tab from this origin
        for (const client of windowClients) {
          if (client.url && client.url.startsWith(origin)) {
            // Focus existing tab
            if (client.focus) {
              client.focus();
            }
            
            // Send navigation message
            client.postMessage({ 
              action: "navigate", 
              url: fullUrl 
            });
            
            client.postMessage({
              type: "NAVIGATE",
              url: fullUrl
            });
            
            return Promise.resolve();
          }
        }
        
        // No existing tab - open new window
        return clients.openWindow(fullUrl).catch((error) => {
          console.error("ðŸ”” [SW] Error opening window:", error);
        });
      })
      .catch((error) => {
        console.error("ðŸ”” [SW] Error in notification click:", error);
      })
  );
});
`;

// Write the generated file to public/firebase-messaging-sw.js
const outputPath = join(__dirname, '..', 'public', 'firebase-messaging-sw.js');
writeFileSync(outputPath, swContent, 'utf8');

console.log('âœ… Successfully generated firebase-messaging-sw.js');
console.log('   - Firebase credentials hidden (fetched from API)');
console.log('   - Token-based authentication enabled');
console.log('   - Full notification redirect logic included');
